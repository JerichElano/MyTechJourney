{
  "uniforms": {
    "u_colors": [
      [
        0.42745098039215684,
        0.7019607843137254,
        0.9294117647058824,
        0.3
      ],
      [
        0.6352941176470588,
        0.7803921568627451,
        0.9019607843137255,
        0.4
      ]
    ],
    "u_intensity": 0.5,
    "u_rays": 0.07,
    "u_reach": 0.01
  },
  "fragmentShader": "// Fragment shader\n\n\n\n// Uniforms\n\nuniform vec2 u_resolution;\n\nuniform vec2 u_mouse;\n\nuniform float u_time;\n\nuniform vec4 u_colors[2];\n\nuniform float u_intensity;\n\nuniform float u_rays;\n\nuniform float u_reach;\n\n\n\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec2 permute(const in vec2 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec3 permute(const in vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(const in vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n#endif\n\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n\n#ifndef FNC_QUINTIC\n#define FNC_QUINTIC \n\nfloat quintic(const in float v) { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec2  quintic(const in vec2 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec3  quintic(const in vec3 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec4  quintic(const in vec4 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\n\n#endif\n\n\n\n#ifndef FNC_PNOISE\n#define FNC_PNOISE\n\nfloat pnoise(in vec2 P, in vec2 rep) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); \n    Pi = mod289(Pi);        \n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = quintic(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat pnoise(in vec3 P, in vec3 rep) {\n    vec3 Pi0 = mod(floor(P), rep); \n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); \n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); \n    vec3 Pf1 = Pf0 - vec3(1.0); \n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = quintic(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat pnoise(in vec4 P, in vec4 rep) {\n    vec4 Pi0 = mod(floor(P), rep); \n    vec4 Pi1 = mod(Pi0 + 1.0, rep); \n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); \n    vec4 Pf1 = Pf0 - 1.0; \n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = quintic(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n#endif\n\n\n\n\n\n\n#ifndef SRGB_EPSILON \n#define SRGB_EPSILON 0.00000001\n#endif\n\n#ifndef FNC_SRGB2RGB\n#define FNC_SRGB2RGB\n\n\n\n\nfloat srgb2rgb(float channel) {\n    return (channel < 0.04045) ? channel * 0.0773993808 : pow((channel + 0.055) * 0.947867298578199, 2.4);\n}\n\nvec3 srgb2rgb(vec3 srgb) {\n    return vec3(srgb2rgb(srgb.r + SRGB_EPSILON), \n                srgb2rgb(srgb.g + SRGB_EPSILON),                 srgb2rgb(srgb.b + SRGB_EPSILON));\n}\n\nvec4 srgb2rgb(vec4 srgb) {\n    return vec4(srgb2rgb(srgb.rgb), srgb.a);\n}\n\n#endif\n\n\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n\n\n#ifndef SRGB_EPSILON \n#define SRGB_EPSILON 0.00000001\n#endif\n\n#ifndef FNC_RGB2SRGB\n#define FNC_RGB2SRGB\n\n\nfloat rgb2srgb(float channel) {\n    return (channel < 0.0031308) ? channel * 12.92 : 1.055 * pow(channel, 0.4166666666666667) - 0.055;\n}\n\nvec3 rgb2srgb(vec3 rgb) {\n    return saturate(vec3(rgb2srgb(rgb.r - SRGB_EPSILON), rgb2srgb(rgb.g - SRGB_EPSILON), rgb2srgb(rgb.b - SRGB_EPSILON)));\n}\n\nvec4 rgb2srgb(vec4 rgb) {\n    return vec4(rgb2srgb(rgb.rgb), rgb.a);\n}\n\n#endif\n\n\n\n#ifndef FNC_MIXOKLAB\n#define FNC_MIXOKLAB\nvec3 mixOklab( vec3 colA, vec3 colB, float h ) {\n\n    #ifdef MIXOKLAB_COLORSPACE_SRGB\n    colA = srgb2rgb(colA);\n    colB = srgb2rgb(colB);\n    #endif\n\n    \n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n                    \n    \n    vec3 lmsA = pow( kCONEtoLMS * colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS * colB, vec3(1.0/3.0) );\n    \n    vec3 lms = mix( lmsA, lmsB, h );\n    \n    \n    vec3 rgb = kLMStoCONE*(lms*lms*lms);\n\n    #ifdef MIXOKLAB_COLORSPACE_SRGB\n    return rgb2srgb(rgb);\n    #else\n    return rgb;\n    #endif\n}\n\nvec4 mixOklab( vec4 colA, vec4 colB, float h ) {\n    return vec4( mixOklab(colA.rgb, colB.rgb, h), mix(colA.a, colB.a, h) );\n}\n#endif\n\n    \n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n\n{\n\n\tvec2 sourceToCoord = coord - raySource;\n\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n\n\t\n\n\treturn clamp(\n\n\t\t(.45 + 0.15 * sin(cosAngle * seedA + u_time * speed)) +\n\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + u_time * speed)),\n\n\t\tu_reach, 1.0) *\n\n\t\tclamp((u_resolution.x - length(sourceToCoord)) / u_resolution.x, u_reach, 1.0);\n\n}\n\n\n\nvoid main()\n\n{\n\n\tvec2 uv = gl_FragCoord.xy / u_resolution.xy;\n\n\tuv.y = 1.0 - uv.y;\n\n\tvec2 coord = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y);\n\n\tfloat speed = u_rays * 10.0;\n\n\t\n\n\t// Set the parameters of the sun rays\n\n\tvec2 rayPos1 = vec2(u_resolution.x * 0.5, u_resolution.y * -0.2);\n\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\n\tfloat raySeedA1 = 36.2214*speed;\n\n\tfloat raySeedB1 = 21.11349*speed;\n\n\tfloat raySpeed1 = 0.6*speed;\n\n\t\n\n\tvec2 rayPos2 = vec2(u_resolution.x * 0.5, u_resolution.y * -0.2);\n\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\n\tfloat raySeedA2 = 22.39910*speed;\n\n\tfloat raySeedB2 = 18.0234*speed;\n\n\tfloat raySpeed2 = 0.1*speed;\n\n\t\n\n\t// Calculate the colour of the sun rays on the current fragment\n\n\tvec4 rays1 =\n\n\t\tvec4(0.,0.,0., .0) +\n\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1) * u_colors[0];\n\n\t \n\n\tvec4 rays2 =\n\n\t\tvec4(0.,0.,0., .0) +\n\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2) * u_colors[1];\n\n\t\n\n\tvec4 fragColor = (rays1) + (rays2);\n\n\t\n\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\n\tfloat brightness = 1.0*u_reach - (coord.y / u_resolution.y);\n\n\tfragColor *= (brightness + (0.5+ u_intensity));\n\n\t//fragColor = pow(fragColor,u_brightness*10.0);\n\n\tgl_FragColor = fragColor;\n\n}\n\n\n\n",
  "vertexShader": "// Vertex shader\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"
}